// Generated by CoffeeScript 1.10.0
(function() {
  var HPromise, e, makeExpire, makeItem, t,
    slice = [].slice;

  HPromise = (function() {
    var error1;
    try {
      return require("bluebird");
    } catch (error1) {
      e = error1;
      return typeof Promise !== "undefined" && Promise !== null ? Promise : function() {
        throw new Error("Bottleneck: install 'bluebird' or use Node 0.12 or higher for Promise support");
      };
    }
  })();

  makeExpire = function(cache, key, exp) {
    var base;
    return typeof (base = setTimeout(function() {
      var ref1;
      if (((ref1 = cache[key]) != null ? ref1.waiting.length : void 0) === 0) {
        return delete cache[key];
      }
    }, exp)).unref === "function" ? base.unref() : void 0;
  };

  makeItem = function(cache, key, exp, element) {
    if (element == null) {
      element = null;
    }
    return {
      element: element,
      expire: makeExpire(cache, key, exp),
      waiting: []
    };
  };

  t = function(promise) {
    var cache;
    if (promise != null) {
      HPromise = promise;
    }
    cache = {};
    this.get = function() {
      var args, cb, exp, fn, i, key, newCached;
      key = arguments[0], exp = arguments[1], fn = arguments[2], args = 5 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 1) : (i = 3, []), cb = arguments[i++];
      if (cache[key] != null) {
        if (cache[key].element != null) {
          return cb.apply({}, cache[key].element);
        } else {
          return cache[key].waiting.push(cb);
        }
      } else {
        newCached = makeItem(cache, key, exp);
        cache[key] = newCached;
        cache[key].waiting.push(cb);
        return setTimeout(function() {
          return fn.apply({}, Array.prototype.concat.call(args, function() {
            var res;
            res = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            clearTimeout(newCached.expire);
            if (res[0] == null) {
              cache[key] = makeItem(cache, key, exp, res);
            } else {
              delete cache[key];
            }
            return newCached.waiting.forEach(function(v) {
              return v.apply({}, res);
            });
          }));
        }, 0);
      }
    };
    this.pget = (function(_this) {
      return function() {
        var args, exp, fn, key, wrapped;
        key = arguments[0], exp = arguments[1], fn = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
        wrapped = function(cb) {
          var err, processed, ref;
          processed = (function() {
            var error1;
            try {
              if (typeof (ref = fn.apply({}, args)).then === 'function') {
                return ref;
              } else {
                return HPromise.resolve(ref);
              }
            } catch (error1) {
              err = error1;
              return HPromise.reject(err);
            }
          })();
          return processed.then(function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return cb.apply({}, Array.prototype.concat(null, args));
          })["catch"](function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return cb.apply({}, Array.prototype.concat({}, args));
          });
        };
        return new HPromise(function(resolve, reject) {
          return _this.get.apply({}, Array.prototype.concat(key, exp, wrapped, function() {
            var args, error;
            error = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return (error != null ? reject : resolve).apply({}, args);
          }));
        });
      };
    })(this);
    return this;
  };

  module.exports = t;

}).call(this);
